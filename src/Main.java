import HMineAlgo.AlgoHMine;

import java.io.*;
import java.util.*;

/**
 * @author Aleksandar Simeonov
 * @version 1.0
 */
public class Main {
    static final String INPUT_FILENAME = "logs_BCS37_20181103_UTF8.txt";
    static final String HEADER = "Time,Event context,Component,Event name,Description,Origin,IP address";
    static final String SEPARATOR = ",";
    static final String HMINE_INPUT_FILENAME = "hMineInput.txt";
    static final String HMINE_RESULT = "result.txt";
    final static int OUTPUT_LIMIT = 5;

    static BufferedReader reader = null;
    static String line = "";
    static Set<String> items = new HashSet<>();
    static List<String> list = new ArrayList<>();
    static Map<Integer, String> results = new TreeMap<>(Collections.reverseOrder());
    static BufferedWriter writer = null;

    /**
     * Method that prints out the top {N} most visited event types in the provided input log.
     *
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(new FileInputStream(new File(INPUT_FILENAME))));
        BufferedWriter bw = new BufferedWriter(new FileWriter(HMINE_INPUT_FILENAME));
        parseLogs(bf, bw);
        String inputForHMine = new File(HMINE_INPUT_FILENAME).getPath();

        runHMineAlgo(inputForHMine);
        bf =  new BufferedReader(new InputStreamReader(new FileInputStream(new File(HMINE_RESULT))));
        parseHmineOutput(bf);
        System.out.println(getResults());
    }

    /**
     * @return A string containing the resulting top {N} elements
     */
    static String getResults() {
        StringBuilder result = new StringBuilder();
        result.append("Top ").append(OUTPUT_LIMIT).append(" event contexts in log: ");
        result.append(System.lineSeparator());
        String[] counter = new String[1];
        counter[0] = "1";
        results.keySet().stream().limit(OUTPUT_LIMIT).forEach((x) -> {
            result.append(counter[0]).append(". ").append(results.get(x)).append(". Occurrences: ").append(x);
            result.append(System.lineSeparator());
            counter[0] = Integer.valueOf(counter[0]) + 1 + "";
        });
        return result.toString();
    }

    /**
     * Method that parses the output text file generated by the HMine algorithm.
     *
     * @param br Buffered Reader with file
     * @throws IOException
     */
    static void parseHmineOutput(BufferedReader br) throws IOException {
        reader = br;
        while ((line = reader.readLine()) != null) {
            String[] pieces = line.split(" #SUP: ");
            String key = list.get(Integer.valueOf(pieces[0]));
            int val = Integer.valueOf(pieces[1]);
            results.put(val, key);
        }
    }

    /**
     * Method that runs the HMine algorithm
     *
     * @param inputForHMine Path to the HMine input
     * @throws IOException
     */
    static void runHMineAlgo(String inputForHMine) throws IOException {
        AlgoHMine algorithm = new AlgoHMine();

        // Uncomment the following line to set the maximum pattern length (number of items per itemset)
        algorithm.setMaximumPatternLength(4);

        algorithm.runAlgorithm(inputForHMine, HMINE_RESULT, 0);
        algorithm.printStats();
    }

    /**
     * Method that parses the logs and outputs them to a file in a format readable by the HMine algorithm.
     * @param br Buffered Reader
     * @param bw Buffered Writer
     * @throws IOException
     */
    static void parseLogs(BufferedReader br, BufferedWriter bw) throws IOException {
        reader = br;
        writer = bw;
        while ((line = reader.readLine()) != null) {
            if (line.contains(HEADER)) {
                continue;
            }
            String[] pieces = line.split(SEPARATOR);
            items.add(pieces[2]);
            list = new ArrayList<>(items);
            writer.append(list.indexOf(pieces[2]) + "");
            writer.newLine();
        }
        writer.close();
    }
}
